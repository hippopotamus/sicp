;3.1
(define (make-accumulator amt)
  (lambda (x)
    (begin (set! amt (+ amt x)))
           amt))
;3.2
(define (make-monitored f)
  (let ((num-calls 0))
    (lambda (arg)
      (cond ((eq? arg 'how-many-calls?) num-calls)
            (else
              (begin (set! num-calls (+ 1 num-calls))
                     (f arg)))))))
;3.3
(define (make-account pw balance)
  (let ((consecutive-attempts 0))
    (define (call-the-cops . args) (error "I called the cops"))
    (define (withdraw amount)
      (if (>= balance amount)
          (begin (set! balance (- balance amount))
                 balance)
          "Insufficient funds"))
    (define (deposit amount)
      (set! balance (+ balance amount))
            balance)
    (define (check-password pass)
      (lambda (f)
        (if (eq? pass pw)
            f
            (if (> consecutive-attempts 5)
                call-the-cops
                (begin (set! consecutive-attempts (+ 1 consecutive-attempts))
                       (error "Incorrect password"))))))
    (define (dispatch pass m)
      (cond ((eq? m 'withdraw)
                  ((check-password pass) withdraw))
            ((eq? m 'deposit)
                  ((check-password pass) deposit))
            (else (error "Unknown request -- MAKE-ACCOUNT" m))))
    dispatch))
;3.5
(define (monte-carlo trials experiment)
  (define (iter trials-remaining trials-passed)
    (cond ((= trials-remaining 0) (/ trials-passed trials))
          ((experiment) (iter (- trials-remaining 1) (+ trials-passed 1)))
          (else (iter (- trials-remaining 1) trials-passed))))
  (iter trials 0))

(define (random-in-range low high)
  (let ((range (- high low)))
    (+ low (random range))))

(define (estimate-integral P x1 x2 y1 y2 trials)
  (define (integral-eq)
    (< (+ (expt (- (random-in-range x1 x2) (car P)) 2)
          (expt (- (random-in-range y1 y2) (cadr P)) 2))
       (expt (/ (- x2 x1) 2) 2)))
  (monte-carlo trials integral-eq))

(define P (list 5 7))

(define (estimate-pi P x1 x2 y1 y2 trials)
  (/ (* (estimate-integral P x1 x2 y1 y2 trials)
        (* (- x2 x1) (- y2 y1)))
     (expt (/ (- x2 x1) 2) 2)))
(estimate-pi P 2.0 8.0 4.0 10.0 10000)
;3.6
(define rand-var 0)
(define (rand cmd)
  (cond ((eq? cmd 'generate) (begin (set! rand-var (- (* (+ rand-var 1) -2) 5)) rand-var));shitty not random num generator lol
        ((eq? cmd 'reset) (lambda (new-init-var) (set! rand-var new-init-var)))
        (else (error "Unknown command. Accepted commands -- generate, reset -- RAND" cmd))))
;3.7
(define (check-password pass attempt consecutive-attempts)
  (lambda (func)
    (if (eq? pass attempt)
        func
        (if (> consecutive-attempts 5)
            call-the-cops
            (begin (set! consecutive-attempts (+ 1 consecutive-attempts))
                   (error "Incorrect password"))))))
(define (make-account pw balance)
  (let ((consecutive-attempts 0))
  (define (call-the-cops . args) (error "I called the cops"))
  (define (withdraw amount)
    (if (>= balance amount)
        (begin (set! balance (- balance amount))
               balance)
        "Insufficient funds"))
  (define (deposit amount)
    (set! balance (+ balance amount))
          balance)
  (define (dispatch pass m)
    (cond ((eq? m 'withdraw)
                ((check-password pass pw consecutive-attempts) withdraw))
          ((eq? m 'deposit)
                ((check-password pass pw consecutive-attempts) deposit))
          (else (error "Unknown request -- MAKE-ACCOUNT" m))))
  dispatch))
(define (make-joint account ogpw jointpw)
  (let ((consecutive-attempts 0))
    (define (dispatch pass m)
      (account ogpw m))
  ((check-password jointpw pass consecutive-attempts) dispatch)))
(define a (make-account 'password 100))
((a 'password 'withdraw) 10)
(define b (make-joint a 'password 'sup))
((b 'sup 'withdraw) 10)
;close but i'm passing vars around wrong. i tried to be too clever with check-pw and now it's annoying passing args
;i should have just redone this
;3.8
(define (funny x)
  (lambda (y)
    (let ((z x))
      (begin (set! x y) z))))
(define f (funny 0))
(+ (f 0) (f 1))
(define g (funny 0))
(+ (g 1) (g 0))
;3.13
(define (reverse x)
  (define (loop x y)
    (if (null? x)
        y
        (let ((temp (cdr x)))
          (set-cdr! x y)
          (loop temp x))))
  (loop x '()))
;3.16
(define (count-pairs x)
  (if (not (pair? x))
      0
      (+ (count-pairs (car x))
         (count-pairs (cdr x))
         1)))
(count-pairs (list 'a 'b 'c))
; => 3
(define second (cons 'a 'b))
(define third (cons 'a 'b))
(define first (cons second third))
  (set-car! third second)
(count-pairs first)
; => 4
(define third (cons 'a 'b))
(define second (cons third third))
(define first (cons second second))
(count-pairs first)
; => 7
(define lst (list 'a 'b 'c))
(set-cdr! (cddr lst) lst)
(count-pairs lst)  ; never returns
;3.17
(define (count-pairs x)
  (let ((already-counted '()))
    (define (count x)
      (if (or (not (pair? x)) (memq x already-counted))
          0
          (begin
            (set! already-counted (cons x already-counted))
            (+ (count (car x))
               (count (cdr x))
               1))))
    (count x)))
;3.18
(define (is-cycle? x)
  (let ((encountered '()))
    (define (cycle-through x)
      (if (not (pair? x))
          #f
          (if (memq x encountered)
               #t
               (begin
                 (set! encountered (cons x encountered))
                 (cycle-through (cdr x))))))
    (cycle-through x)))
(define one (list 'a))
(define two (cons one 'b))
(define three (cons two one))
(set-car! one three)
(set-cdr! one two)
(set-cdr! two three)
;3.19
(define (is-cycle? x)
  (let ((encountered '()))
    (define (cycle-through x)
      (if (not (pair? x))
          #f
          (if (eq? x encountered)
               #t
                 (if (not (pair? encountered))
                   (begin
                     (set! encountered (car x))
                     (cycle-through (cdr x)))
                   (cycle-through (cdr x))))))
    (cycle-through x)))
;3.21
(define (front-ptr queue) (car queue))
(define (rear-ptr queue) (cdr queue))
(define (set-front-ptr! queue item) (set-car! queue item))
(define (set-rear-ptr! queue item) (set-cdr! queue item))
(define (empty-queue? queue) (null? (front-ptr queue)))
(define (make-queue) (cons '() '()))
(define (front-queue queue)
  (if (empty-queue? queue)
    (error "FRONT called with an empty queue" queue)
    (car (front-ptr queue))))
(define (insert-queue! queue item)
  (let ((new-pair (cons item '())))
    (cond ((empty-queue? queue)
            (set-front-ptr! queue new-pair)
            (set-rear-ptr! queue new-pair)
            queue)
          (else
            (set-cdr! (rear-ptr queue) new-pair)
            (set-rear-ptr! queue new-pair)
            queue))))
(define (delete-queue! queue)
  (cond ((empty-queue? queue)
          (error "DELETE! called with an empty queue" queue))
        (else
          (set-front-ptr! queue (cdr (front-ptr queue)))
          queue)))
(define (print-queue queue)
  (front-ptr queue))
(define q1 (make-queue))
(insert-queue! q1 'a)
(insert-queue! q1 'b)
(insert-queue! q1 'c)
(insert-queue! q1 'd)
;3.22
(define (make-queue)
  (let ((front-ptr '())
        (rear-ptr '()))
    (define (set-front-ptr! item) (set! front-ptr item))
    (define (set-rear-ptr! item) (set! rear-ptr item))
    (define (empty-queue?) (null? front-ptr))
    (define (front-queue)
      (if (empty-queue?)
          (error "FRONT called with an empty queue")
          (car front-ptr)))
    (define (insert-queue! item)
      (let ((new-pair (cons item '())))
        (cond ((empty-queue?)
                (set-front-ptr! new-pair)
                (set-rear-ptr! new-pair)
                front-ptr)
              (else
                (set-cdr! rear-ptr new-pair)
                (set-rear-ptr! new-pair)
                front-ptr))))
    (define (delete-queue!)
      (cond ((empty-queue?)
              (error "DELETE! called with an empty queue"))
            (else
              (set-front-ptr! (cdr front-ptr)))))
    (define (print-queue) front-ptr)
    (define (dispatch m)
      (cond ((eq? m 'set-front-ptr!) set-front-ptr!)
            ((eq? m 'set-rear-ptr!) set-rear-ptr!)
            ((eq? m 'empty-queue?) (empty-queue?))
            ((eq? m 'front-queue) (front-queue))
            ((eq? m 'insert-queue!) insert-queue!)
            ((eq? m 'delete-queue!) (delete-queue!))
            ((eq? m 'print-queue) (print-queue))
            (else (error "Unknown request -- QUEUE" m))))
  dispatch))
(define q1 (make-queue))
((q1 'insert-queue!) 'a)
;3.23
(define (make-deque)
  (let ((front-ptr '())
        (rear-ptr '()))
    (define (empty?) (null? front-ptr))
    (define (front)
      (if (empty?)
          (error ("FRONT called with empty deque"))
          (car front-ptr)))
    (define (rear)
      (if (empty?)
          (error ("REAR called with empty deque"))
          (car rear-ptr)))
    (define (remove-last-el lst build)
      (if (null? (cdr lst))
           build
           (remove-last-el (cdr lst) (append build (list (car lst))))))
    (define (front-insert! item)
      (let ((new-pair (cons item '())))
        (if (empty?)
            (begin
              (set! front-ptr new-pair)
              (set! rear-ptr new-pair)
              front-ptr)
            (begin
              (set! front-ptr (cons item front-ptr))
              (set! rear-ptr (append rear-ptr new-pair))
              front-ptr))))
    (define (rear-insert! item)
      (let ((new-pair (cons item '())))
        (if (empty?)
            (begin
              (set! front-ptr new-pair)
              (set! rear-ptr new-pair)
              rear-ptr)
            (begin
              (set! front-ptr (append front-ptr new-pair))
              (set! rear-ptr (cons item rear-ptr))
              rear-ptr))))
    (define (front-delete!)
      (if (empty?)
          (error ("FRONT-DELETE called with empty deque"))
          (begin
            (set! front-ptr (cdr front-ptr))
            (set! rear-ptr (remove-last-el rear-ptr '()))
            front-ptr)))
    (define (rear-delete!)
      (if (empty?)
          (error ("REAR-DELETE called with empty deque"))
          (begin
            (set! rear-ptr (cdr rear-ptr))
            (set! front-ptr (remove-last-el front-ptr '()))
            rear-ptr)))
    (define (print-forward) front-ptr)
    (define (print-backward) rear-ptr)
    (define (dispatch m)
      (cond ((eq? m 'empty?) (empty?))
            ((eq? m 'front) (front))
            ((eq? m 'rear) (rear))
            ((eq? m 'front-insert!) front-insert!)
            ((eq? m 'rear-insert!) rear-insert!)
            ((eq? m 'front-delete!) (front-delete!))
            ((eq? m 'rear-delete!) (rear-delete!))
            ((eq? m 'print-forward) (print-forward))
            ((eq? m 'print-backward) (print-backward))
            (else (error "Unknown request -- DEQUE" m))))
    dispatch))
(define d (make-deque))
((d 'rear-insert!) '2)
((d 'front-insert!) '1)
((d 'rear-insert!) '3)
((d 'rear-insert!) '4)
(d 'print-forward)
(d 'front-delete!)
(d 'print-backward)
(d 'rear-delete!)
(d 'print-forward)
